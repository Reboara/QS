/*
В систему поступают заявки, время между приходом соседних заявок
распределено по экспоненциальному закону со средним значением R1
секунд. Их обработка выполняется в 2 стадии. 
    Рабочие типа 1 могут
выполнять только первый тип работ, время выполнения распределено
экспоненциально со средним значением T1(R1+G1+B1) секунд. 
    Рабочие типа 2
могут выполнять только второй тип работ, время выполнения распределено
экспоненциально со средним значением T2(R2+G2+B2) секунд. 
    Рабочие типа 3
могут выполнять оба типа работ, время выполнения распределено
экспоненциально со средним значением T3(R3+G3+B3+G1) секунд для первого
типа работ и T4(R3+G3+B3+B1) секунд для второго типа работ. Рабочие типа 3
задействуются только тогда, когда образуются очереди, при этом они
выбирают для исполнения заявку из более длинной очереди. 

Требуется разработать дискретно-событийную имитационную модель, которая должна
позволять оценивать показатели загруженности системы. Кроме того, модель
должна формировать лог моделирования, который бы иллюстрировал
продвижение заявок в цепях событий FEC и CEC. С помощью разработанной
модели требуется обосновать минимально требуемое число рабочих каждого
типа, чтобы обеспечить среднее число заявок в каждой из очередей на уровне
не более 2.

Queueing System = СМО
*/

#include <ctime>
#include <iostream>
#include "SMO.h"

int n = 2, m = 2, k = 2;
int T1 = 10+11+7, T2 = 8+9+8, T3 = 5+11+9+11, T4 = 5+11+9+7;

int main (int argc, char* argv[]) {
    std::srand(std::time(nullptr));
    QS SMO(n, m, k);

    SMO.modeling(200);
    
    return 0;
}

/*
    Typical_Worker W1(n, T1), W2(m, T2);
    Worker W[]{Worker(n, T1), Worker(m, T2)};

    vector<int> number = {2, 3, 5};
    cout << number[0] << endl;
    number[0] += 1;
    cout << number[0] << endl;

    std::queue<int> q1;
    q1.push(10);
    q1.push(20);
    std::queue<int> q2;
    q2.push(5);
    q2.push(24);

    cout<<q1.size()<<endl;
    cout<<q1.front()<<endl;
    cout<<q1.size()<<endl;

    cout << W1 << W2;
    for (int i = 0; i < m; i++) {
        W2.ready_time[i] = std::rand()%100;
    }

    // for (auto item = mat.begin(); item != mat.end(); ++item)
    // for (auto item = W1.begin(); item != W1.end(); ++item) {
    for (auto &item : W1) {
        item = std::rand()%100;
    }

    cout << "Filling is done.\n";
    cout << W1 << W2;
    cout << "Printing is done.\n";
*/